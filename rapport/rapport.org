#+INCLUDE: "header.org"

* Introduction

** Le domaine du calcul haute performance
    - paradigme de programmation parallèle en tâches
    - architecture hétérogène (plusieurs GPUs, plusieurs bancs NUMA...)
** L'équipe Inria /STORM/
    - /Runtime/ : donner une définition
      + composant entre le système d'exploitation et l'utilisateur (libraire
        d'algèbre linéaire parallèle)
      + ordonnanceur pour des applications d'algèbre linéaire classique

** Ordonnancement de tâches pour applications stencils
    - qu'est-ce qu'une application stencil ?
    - classe d'algorithmes beaucoup utilisé en simulation
    - pour discrétiser des phénomènes physiques locaux sur des grilles
      régulières
    - on applique une petite fonction (noyau) sur l'ensemble du domaine, de
      manière itérative (figure [[fig:3D_stencil]])
    - noyau : chaque cellule est mise à jour en fonction du voisinage

#+NAME: fig:3D_stencil
#+CAPTION: Stencil 6-points 3D - La mise à jour d'un élément se fait à partir
#+CAPTION: des 6 éléments voisins cite:6points-stencil.
#+ATTR_LATEX: :width 0.4\linewidth
[[file:img/3D_stencil.png]]

** Schéma de calcul particulier des stencils
 - Beaucoup de communications avec les voisinage
    - un ratio accès mémoire par calcul élevé
    - il devient difficile voir impossible de recouvrir totalement les temps de
      transferts entre les noeuds mémoires avec du calcul

** Comment économiser de la bande passante
    - Travail sur la localité des données
      + localité en espace
      + localité en temps
** Ce à quoi je me suis intéressé durant le stage
** État de l'art

*** Le problème des applications stencils
    - On rappelle le contexte et le problème :
      + Dans le cadre des Runtimes et de la programmation parallèle en tâches
      + Trouver des solutions d'ordonnancement de tâches stencils
*** Solutions existantes au problème
    - Travaux précédents qui ont portés sur l'ordonnancement pour de l'algègre
      linéaire
    - assez peu de travax sur les stencils
    - Parcours cache oblivious
    - On simule de la localité en donnant des tâches avec des prioritées
      indexées sur le numéro d'itération

*** il manque donc quelque chose : à expliquer / détailler ici

* Contribution du stage
  
** Résumé de la contribution

 - Comportement des ordonnaceurs de StarPU, 3 métriques
   + temps d'exécution
   + surcoût : temps passé à ordonnancer les tâches
   + volume des transferts gpu/gpu ou cpu/gpu
 - Pour réduire le volume de com. : travail sur la localité : prototype d'outils de visualisation
 - Trouver une méthode de référence : face à cache oblivious

** Outils de visualisation

*** Diagramme de Gantt temps x domaine
*** Diagramme domaine x itérations

** Un autre élément d'implémentation

** Évaluation et validation

*** Expérimentation : montrer et donc expliquer certaines courbes ou images intéressantes

*** Permet d'appuyer la pertinence des travaux présentés

* Conclusion

** Court résumé des points importants

*** Problème initial

*** Contribution

*** Validation

** Perspectives

*** Court terme (faute de temps) : autre solution technique figurant sur l'arbre des solutions, cul-de-sac

*** Long terme : quelles sont les voies d'exploration non envisagées au départ ?

#+LATEX: \clearpage
#+LATEX: \printbibliography
